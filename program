# telegram_app.py
# -*- coding: utf-8 -*-
import asyncio
import json
import os
import time
from typing import Any, Dict, List, Optional, Union, Tuple

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from telethon import TelegramClient
from telethon.errors import FloodWaitError, RPCError

CONFIG_PATH = os.getenv("TG_CONFIG_PATH", "tg_config.json")
APP_HOST = os.getenv("TG_APP_HOST", "127.0.0.1")
APP_PORT = int(os.getenv("TG_APP_PORT", "5001"))

# ----------------- config -----------------
def load_config() -> Dict[str, Any]:
    if not os.path.isfile(CONFIG_PATH):
        raise RuntimeError(f"Config not found: {CONFIG_PATH}")
    with open(CONFIG_PATH, "r", encoding="utf-8") as f:
        cfg = json.load(f)
    for k in ("api_id", "api_hash", "session_name"):
        if k not in cfg or not cfg[k]:
            raise RuntimeError(f"Missing config key: {k}")
    cfg.setdefault("send_delay_sec", 0.6)
    cfg.setdefault("default_targets", [])
    return cfg

CFG = load_config()

# ----------------- telegram client -----------------
client = TelegramClient(CFG["session_name"], int(CFG["api_id"]), str(CFG["api_hash"]))

async def ensure_login() -> None:
    """
    ĞŸĞµÑ€Ğ²Ñ‹Ğ¹ Ğ·Ğ°Ğ¿ÑƒÑĞº ÑĞ¿Ñ€Ğ¾ÑĞ¸Ñ‚ Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ° Ğ¸ ĞºĞ¾Ğ´ (Ğ² ĞºĞ¾Ğ½ÑĞ¾Ğ»Ğ¸).
    ĞŸĞ¾ÑĞ»Ğµ ÑÑ‚Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°ÑÑ‚ .session Ñ„Ğ°Ğ¹Ğ» Ğ¸ Ğ´Ğ°Ğ»ÑŒÑˆĞµ Ğ±ÑƒĞ´ĞµÑ‚ Ğ»Ğ¾Ğ³Ğ¸Ğ½Ğ¸Ñ‚ÑŒÑÑ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸.
    """
    if not client.is_connected():
        await client.connect()

    if not await client.is_user_authorized():
        # Telethon ÑĞ°Ğ¼ ÑĞ¿Ñ€Ğ¾ÑĞ¸Ñ‚ Ğ½Ğ¾Ğ¼ĞµÑ€ Ğ¸ ĞºĞ¾Ğ´ Ğ² stdin
        print("\n[TELEGRAM] Not authorized. Starting interactive sign-in...")
        await client.start()
        print("[TELEGRAM] Authorized OK.")
    else:
        # Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‡Ñ‚Ğ¾ ÑĞµÑÑĞ¸Ñ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ğ°Ñ
        pass

# ----------------- models -----------------
Target = Union[str, int]

class SendPayload(BaseModel):
    # "sql_table" style
    table_name: Optional[str] = None
    columns: Optional[List[str]] = None
    rows: Optional[List[Dict[str, Any]]] = None

    # or generic payload
    text: Optional[str] = None
    data: Optional[Dict[str, Any]] = None

    # where to send
    targets: Optional[List[Target]] = None

    # optional: mention if you want manual title
    title: Optional[str] = None


# ----------------- formatting -----------------
def format_as_message(payload: SendPayload) -> str:
    if payload.text:
        return payload.text.strip()

    if payload.rows is not None:
        title = payload.title or payload.table_name or "SQL table"
        cols = payload.columns
        if not cols and payload.rows:
            # Ğ±ĞµÑ€ĞµĞ¼ ĞºĞ»ÑÑ‡Ğ¸ Ğ¸Ğ· Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
            cols = list(payload.rows[0].keys())

        lines = [f"ğŸ“Œ {title}"]
        if cols:
            lines.append(" | ".join(map(str, cols)))
            lines.append("-" * min(60, max(10, len(lines[-1]))))

        # Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ¼ Ğ´Ğ»Ğ¸Ğ½Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ ÑƒĞ»ĞµÑ‚ĞµÑ‚ÑŒ Ğ² Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ñ‹
        max_rows = 30
        for i, r in enumerate(payload.rows[:max_rows], start=1):
            if cols:
                lines.append(" | ".join(str(r.get(c, "")) for c in cols))
            else:
                lines.append(str(r))
        if len(payload.rows) > max_rows:
            lines.append(f"... Ğ¸ ĞµÑ‰Ñ‘ {len(payload.rows) - max_rows} ÑÑ‚Ñ€Ğ¾Ğº(Ğ¸)")

        return "\n".join(lines).strip()

    if payload.data is not None:
        title = payload.title or "Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ"
        # pretty json
        body = json.dumps(payload.data, ensure_ascii=False, indent=2)
        # Telegram Ğ»ÑĞ±Ğ¸Ñ‚ ÑƒĞ¼ĞµÑ€ĞµĞ½Ğ½Ñ‹Ğµ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ñ‹
        if len(body) > 3500:
            body = body[:3500] + "\n... (truncated)"
        return f"ğŸ“Œ {title}\n{body}"

    # fallback: Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ payload
    return "âš ï¸ ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½ Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ payload (Ğ½ĞµÑ‚ text/data/rows)."


# ----------------- sending core -----------------
async def resolve_entity(t: Target):
    """
    Telethon Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚: @username, ÑÑÑ‹Ğ»ĞºĞ¸ t.me, numeric id, entity.
    Ğ—Ğ´ĞµÑÑŒ Ğ´ĞµĞ»Ğ°ĞµĞ¼ ĞµĞ´Ğ¸Ğ½Ñ‹Ğ¹ resolve, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ·Ğ°Ñ€Ğ°Ğ½ĞµĞµ ÑƒĞ¿Ğ°ÑÑ‚ÑŒ, ĞµÑĞ»Ğ¸ Ñ‡Ğ°Ñ‚ Ğ½ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹.
    """
    return await client.get_entity(t)

async def send_to_targets(text: str, targets: List[Target], delay_sec: float) -> Dict[str, Any]:
    report = {
        "ok": [],
        "failed": [],
        "total": len(targets),
        "started_at": int(time.time()),
        "finished_at": None,
    }

    for idx, t in enumerate(targets, start=1):
        try:
            entity = await resolve_entity(t)
            await client.send_message(entity, text)
            report["ok"].append({"target": t, "index": idx})
            # Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ°Ñ Ğ¿Ğ°ÑƒĞ·Ğ°, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ Ñ‚Ñ€Ğ¸Ğ³Ğ³ĞµÑ€Ğ¸Ñ‚ÑŒ Ñ„Ğ»ÑƒĞ´
            await asyncio.sleep(delay_sec)
        except FloodWaitError as e:
            # Telegram Ğ¿Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¸Ğ» Ğ¿Ğ¾Ğ´Ğ¾Ğ¶Ğ´Ğ°Ñ‚ÑŒ
            wait_s = int(getattr(e, "seconds", 0) or 0)
            report["failed"].append({"target": t, "index": idx, "error": f"FLOOD_WAIT_{wait_s}s"})
            # ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ»Ğ¸Ğ±Ğ¾ Ğ¶Ğ´Ğ°Ñ‚ÑŒ, Ğ»Ğ¸Ğ±Ğ¾ ÑÑ€Ğ°Ğ·Ñƒ Ğ¾Ñ‚Ñ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°Ñ‚ÑŒÑÑ. Ğ¯ Ğ´ĞµĞ»Ğ°Ñ "Ğ¶Ğ´Ğ°Ñ‚ÑŒ Ğ¸ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ñ‚ÑŒ"
            if wait_s > 0 and wait_s < 60:
                await asyncio.sleep(wait_s + 1)
                # Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· Ğ¾Ğ´Ğ¸Ğ½ Ñ€Ğ°Ğ·
                try:
                    entity = await resolve_entity(t)
                    await client.send_message(entity, text)
                    report["ok"].append({"target": t, "index": idx, "retry": True})
                except Exception as e2:
                    report["failed"].append({"target": t, "index": idx, "error": f"RETRY_FAIL: {type(e2).__name__}: {e2}"})
        except RPCError as e:
            report["failed"].append({"target": t, "index": idx, "error": f"RPCError: {type(e).__name__}: {e}"})
        except Exception as e:
            report["failed"].append({"target": t, "index": idx, "error": f"{type(e).__name__}: {e}"})

    report["finished_at"] = int(time.time())
    return report


# ----------------- fastapi -----------------
app = FastAPI(title="telegram_app", version="1.0")

@app.on_event("startup")
async def on_startup():
    await ensure_login()
    print(f"[telegram_app] ready on http://{APP_HOST}:{APP_PORT}")

@app.on_event("shutdown")
async def on_shutdown():
    try:
        await client.disconnect()
    except Exception:
        pass

@app.get("/health")
async def health():
    return {"status": "ok", "authorized": await client.is_user_authorized()}

# Ğ’ĞĞ–ĞĞ: forwarder Ñƒ Ñ‚ĞµĞ±Ñ Ğ¿Ğ¾ÑÑ‚Ğ¸Ñ‚ Ğ¿Ñ€ÑĞ¼Ğ¾ Ğ² TELEGRAM_APP_URL Ğ±ĞµĞ· path :contentReference[oaicite:2]{index=2}
# ĞŸĞ¾ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ´ĞµĞ»Ğ°ĞµĞ¼ POST "/" ĞºĞ°Ğº "Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ñ Ñ‡Ñ‚Ğ¾ ÑƒĞ³Ğ¾Ğ´Ğ½Ğ¾".
@app.post("/")
async def receive_any(order: Dict[str, Any]):
    # ĞŸÑ€ĞµĞ²Ñ€Ğ°Ñ‚Ğ¸Ğ¼ ÑÑ‚Ğ¾ Ğ² ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ¼ Ğ¿Ğ¾ default_targets
    targets = CFG.get("default_targets", [])
    if not targets:
        raise HTTPException(status_code=400, detail="No default_targets in tg_config.json")

    payload = SendPayload(data=order, title="ĞĞ¾Ğ²Ğ°Ñ Ğ·Ğ°ÑĞ²ĞºĞ°")
    text = format_as_message(payload)
    report = await send_to_targets(text, targets, float(CFG.get("send_delay_sec", 0.6)))
    return {"status": "ok", "sent": report}

# Ğ‘Ğ¾Ğ»ĞµĞµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼Ñ‹Ğ¹ endpoint: Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‚ÑŒ targets Ğ²Ğ¼ĞµÑÑ‚Ğµ Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸
@app.post("/send")
async def send(payload: SendPayload):
    targets = payload.targets or CFG.get("default_targets", [])
    if not targets:
        raise HTTPException(status_code=400, detail="targets required (or set default_targets in config)")

    text = format_as_message(payload)
    report = await send_to_targets(text, targets, float(CFG.get("send_delay_sec", 0.6)))
    return {"status": "ok", "sent": report}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host=APP_HOST, port=APP_PORT)
